#' Creates a new Hotgenes object
#' from user-provided objects.
#' @export
#' @param Output_DE (Required). A named list of data.frames.
#' Each data.frame contains atleast: "Feature", "baseMean","log2FoldChange",
#' "stat", "pvalue", "padj".
#' @param Normalized_Expression (Required). A named list of data.frames available
#' expression data. Columns must be sample names and rows must be features.
#' @param auxiliary_assays (Optional). A data.frame with a SampleIDs column
#' matching the rownames of coldata object. This data.frame can be used
#' to store auxiliary data, such as clinical scores, observations, and/or 
#' low-throughput assay data. See details below.
#' @param coldata (Required). A data.frame with sample metadata.
#' Rownames must match column names of expression data. Columns are design
#' varaibles or sample metadata.
#' @param designMatrix (Required). The model matrix or comparison used for
#' DE analysis.
#' @param contrastMatrix (optional). The contrast matrix used for
#' DE analysis, if different from designMatrix.
#' @param Original_Object (Optional). This is the original DE object used
#' for DE analysis, such as limma fit object.
#' @param Mapper (Required). A data.frame that can be used
#' to map aliases to original assay names. Must have a
#' "Feature" column, which will be used for mapping to results. This object
#' can be updated or viewed using Mapper_.
#' @example man/examples/HotgenesUniversal_Example.R

HotgenesUniversal <- function(Output_DE = NULL,
                              Normalized_Expression = NULL,
                              auxiliary_assays = NULL,
                              coldata = NULL,
                              Original_Object = NULL,
                              designMatrix = NULL,
                              contrastMatrix  = NULL,
                              Mapper = NULL) {
  
  # makes default aux assays
  default_auxiliary_assays <- auxiliary_assays_frame(
    SampleIDs = rownames(coldata)) %>%
    tibble::as_tibble()
 
  
  # prep Output_DE standard
  # pulling slot

Output_DE <- Output_DE %>%
purrr::imap( ~.x %>%
dplyr::mutate(contrast = .y, .after = "padj") %>% 
dplyr::mutate(contrast_dir = dplyr::case_when(
sign(.data$stat) == 1 ~ glue::glue("{.data$contrast}_up"),
sign(.data$stat) == -1 ~ glue::glue("{.data$contrast}_down")

) %>% as.character(), 
.after = "Feature")  %>%

dplyr::mutate(FC = 2^.data$log2FoldChange, .before = "log2FoldChange")  %>%
tibble::as_tibble()
)


if(is.null(Mapper)){
  
  Mapper <- Normalized_Expression %>% 
    purrr::map(~base::row.names(.x)) %>% unlist(use.names = FALSE) %>% 
    unique() %>% sort()
  
  Mapper <- data.frame(Feature = Mapper) %>%
    tibble::as_tibble()
  
}
  
  # makes object
  Hotgenes_Object <- new(
    "Hotgenes",
    Output_DE = Output_DE,
    Normalized_Expression = Normalized_Expression,
    auxiliary_assays = tibble::as_tibble(default_auxiliary_assays),
    coldata = coldata,
    Original_Object = Original_Object,
    designMatrix = designMatrix,
    contrastMatrix = contrastMatrix,
    Mapper = tibble::as_tibble(Mapper)
  )
  
  
    
  # check auxiliary_assays 
  if(!is.null(auxiliary_assays)) {
    
    auxiliary_assays_(Hotgenes_Object) <- auxiliary_assays %>%
      tibble::as_tibble()
    
  }   
  
  return(Hotgenes_Object)
}

#' Exports DESeq2 object to Hotgenes
#' @importFrom grDevices dev.off recordPlot
#' @importFrom dplyr mutate mutate_at mutate_all pull select select_if
#' @importFrom dplyr all_of any_of desc relocate case_when across everything
#' @importFrom dplyr arrange arrange_at filter filter_at
#' @importFrom dplyr full_join left_join slice summarise summarise_all
#' @importFrom dplyr group_by group_by_at group_keys group_split
#' @importFrom dplyr n rename rename_at row_number if_any matches
#' @importFrom purrr chuck reduce map_chr map_dfr
#' @importFrom tibble has_rownames
#' @importFrom tibble enframe deframe as_tibble column_to_rownames
#' @importFrom purrr imap map set_names
#' @importFrom grDevices colorRampPalette
#' @importFrom utils head
#' @importFrom rlang .data
#' @importFrom SummarizedExperiment colData assay
#' @export
#' @importFrom DESeq2 normTransform varianceStabilizingTransformation rlog
#' @importFrom DESeq2 lfcShrink resultsNames
#' @param DEseq2_object the output object generated by DESeq2
#' @param lfcShrink_type "normal" (Default) is the original DESeq2 shrinkage
#' estimator. Other options is "apeglm".
#' @param contrasts values from DESeq2 resultsNames function. If NULL
#' (default) DE for all results will be reported.
#' @param ExpressionData String for normalization method.
#' Options are "log2" (normTransform),
#' "vsd" (varianceStabilizingTransformation), and,
#' "rld" (rlog).
#' @param ... Additional parameters for \code{\link[DESeq2]{lfcShrink}}.
#' @inheritParams HotgenesUniversal
#' @description This pulls DE results using lfcShrink function of
#' DESeq2. For downstream GSEA, the "stat" column can be used. However,
#' in the case of lfcShrink via "apeglm" when no stat column is provided,
#' one will be generated using the following equation:
#' -log10(.data$pvalue)*sign(.data$log2FoldChange)
#'
#' @seealso \code{\link[DESeq2]{lfcShrink}}
#' @example man/examples/HotgenesDEseq2_Example.R



HotgenesDEseq2 <- function(DEseq2_object = NULL,
                           lfcShrink_type = "normal",
                           contrasts = NULL,
                           ExpressionData = c("rld", "vsd", "log2"),
                           auxiliary_assays = NULL,
                           Mapper = NULL,
                           ...) {
  stopifnot(class(DEseq2_object) == "DESeqDataSet")
  
  # Setup output conditions -------------------------------------------------
  # get coldata data
  coldata <- SummarizedExperiment::colData(DEseq2_object) %>%
    base::as.data.frame() %>%
    dplyr::select(-dplyr::any_of(c("sizeFactor", "replaceable")))
  
  # get designMatrix
  designMatrix <- attr(DEseq2_object, "modelMatrix")
  
  # getting available contrasts, excluding Intercept
  available_contrasts <-
    DESeq2::resultsNames(DEseq2_object)[!grepl("Intercept",
                                               DESeq2::resultsNames(DEseq2_object),
                                               ignore.case = TRUE)]
  
  
  if (is.null(contrasts)) {
    Output_contrasts <- available_contrasts
  } else if (!is.null(contrasts)) {
    Output_contrasts <-
      available_contrasts[available_contrasts %in% contrasts]
  }
  
  
  # Output_DE ---------------------------------------------------------------
  
  Output_DE <- Output_contrasts %>%
    purrr::set_names(~ .x) %>%
    purrr::imap(function(xList, yList) {
      out_lfcSh <- DESeq2::lfcShrink(
        DEseq2_object,
        coef = yList,
        type = lfcShrink_type,
        ...
      ) %>%
        base::as.data.frame() %>%
        tibble::rownames_to_column(var = "Feature") %>%
        dplyr::arrange(.data$padj)
      
      # Calculating stat for GSEA
      if (lfcShrink_type == "apeglm") {
        out_lfcSh <- out_lfcSh %>%
          dplyr::mutate(stat = (-log10(.data$padj) * sign(.data$log2FoldChange)))
      }
      
      return(out_lfcSh)
    })
  
  
  # Normalized Expression Data ----------------------------------------------
  
  # matching normalization
  Sel_Norm <- match.arg(
    arg = ExpressionData,
    choices = c("rld", "vsd", "ntd", "log2"),
    several.ok = TRUE
  )
  
  # Replacing ntd with log2
  Sel_Norm <- gsub("ntd", "log2", Sel_Norm) %>%
    unique() %>%
    purrr::set_names(~ .x)
  
  
  Normalized_Expression <- Sel_Norm %>%
    purrr::imap(function(x, y) {
      if (x %in% c("ntd", "log2")) {
        TempExprs <- DESeq2::normTransform(DEseq2_object)
      } else if (x == "vsd") {
        TempExprs <-
          DESeq2::varianceStabilizingTransformation(DEseq2_object, blind = FALSE)
      } else if (x == "rld") {
        TempExprs <- DESeq2::rlog(DEseq2_object, blind = FALSE)
      }
      
      TempExprs <-
        data.frame(SummarizedExperiment::assay(TempExprs),
                   check.names = FALSE)
      return(TempExprs)
    })
  
  
  # Check Mapper
  if (is.null(Mapper)) {
    Features_names_List <- Normalized_Expression %>%
      purrr::map(function(x) {
        rownames(x)
      }) %>%
      unlist(use.names = FALSE) %>%
      unique() %>%
      sort()
    
    
    mapperFrame <- data.frame(Feature = Features_names_List,
                              stringsAsFactors = FALSE) %>%
      tibble::as_tibble()
  } else if (!is.null(Mapper)) {
    mapperFrame <- base::as.data.frame(Mapper) %>% tibble::as_tibble()
  }
  
 # check auxiliary_assays 
  if(is.null(auxiliary_assays)) {
    
    samplesNames <- rownames(coldata)
    
    auxiliary_assays <-   auxiliary_assays_frame(SampleIDs = samplesNames) 
  } 
  
  # Hotgenes ----------------------------------------------------------------
  # HotgenesUniversal
  
  Hotgenes_Object <- HotgenesUniversal(
    Output_DE = Output_DE,
    Normalized_Expression = Normalized_Expression,
    auxiliary_assays = auxiliary_assays,
    coldata = coldata,
    designMatrix = designMatrix,
    Original_Object = DEseq2_object,
    Mapper = mapperFrame
  )
  
  return(Hotgenes_Object)
}

#' Exports limma DE analysis to Hotgenes
#' @export
#' @importFrom limma topTable
#' @importFrom stats model.matrix
#' @importFrom plyr dlply
#' @param limmafit the fit generated by limma
#' @param coldata data.frame containing Experimental design metadata
#' @param contrasts colnames of limmafit object, returned using the colnames
#' function. If NULL, default, DE for all results will be reported.
#' @param Expression R object containing the expression data
#' used for limma differential expression analysis.

#' @param Expression_name String used to name the expression data slot. Default
#' is "Normalized_data".
#' @param Exps_list Optional named list of additional expression data to
#' include. Default is NULL. All list objects will be converted to data.matrix.
#' @inheritParams HotgenesDEseq2
#' @inheritParams limma::topTable
#' @return Hotgenes object
#' @details This exports DE via limma::topTable function.
#' Some columns are renamed.
#' The P.Value column is renamed to pvalue.
#' The adj.P.Val column is renamed to padj.
#' The logFC column is renamed to log2FoldChange.
#' The AveExpr column is renamed to baseMean.
#' A stat column wil be added, which is generated with the
#' following equation: -log10(.data$pvalue)*sign(.data$log2FoldChange)
#'
#' topTable will be used for each contrast,
#' individually.
#'
#' @seealso limma::topTable
#' @example man/examples/Hotgeneslimma_Example.R

Hotgeneslimma <- function(limmafit = NULL,
                          coldata = NULL,
                          Expression = NULL,
                          adjust.method = "BH",
                          contrasts = NULL,
                          auxiliary_assays = NULL,
                          Expression_name = "Normalized_data",
                          Exps_list = NULL,
                          Mapper = NULL) {
  # Check limmafit object
  stopifnot(is(limmafit, "MArrayLM"))
  stopifnot(is(Expression, "EList"))
  
  # check Expression_name
  if (is.null(Expression_name)) {
    stop("No expression name given")
  }
  
  # Setup output conditions -------------------------------------------------
  # verify that coldata and expression data align
  if (!all(rownames(coldata) == colnames(Expression))) {
    stop("coldata does not match Expression")
  }
  
  # verify that rownames(limmafit$design) and expression data align
  if (!all(rownames(limmafit$design) == colnames(Expression))) {
    stop("limmafit$design does not match Expression")
  }
  
  # getting available contrasts by removing intercept
  available_contrasts <- colnames(limmafit)[!grepl("Intercept",
                                                   colnames(limmafit),
                                                   ignore.case = TRUE)]
  
  if (is.null(contrasts)) {
    Output_contrasts <- available_contrasts
  } else if (!is.null(contrasts)) {
    Output_contrasts <-
      available_contrasts[available_contrasts %in% contrasts]
  }
  
  
  # Output_DE ---------------------------------------------------------------
  
  
  
  # Getting DE info via topTable
  Output_Temp <- Output_contrasts %>%
    purrr::set_names(~ .x) %>%
    purrr::imap(function(x, y) {
      # Getting DE info via topTable
      Output_topTable <- topTable(
        fit = limmafit,
        coef = y,
        number = Inf,
        adjust.method = adjust.method,
        p.value = 1,
        sort.by = "none"
      ) %>%
        # when only one contrast is reported, the column name is logFC
        # If a column matches this, it will be changed to Fixed_contrasts
        # rename_at(vars(matches("^logFC$")), function(x) make.names(y))
        dplyr::rename_with(function(x)
          make.names(y), dplyr::matches("^logFC$"))
      
      # Geting matched names
      CoefCols <- Output_topTable %>%
        dplyr::select(dplyr::any_of(make.names(y))) %>%
        names()
     
      # converting Output_Temp to Output_DE
      Output_topTable %>%
        tibble::rownames_to_column(var = "Feature") %>%
        tidyr::pivot_longer(names_to = "contrast",
                            values_to = "log2FoldChange",
                            dplyr::all_of(CoefCols)) %>%
        dplyr::rename(pvalue = "P.Value") %>%
        dplyr::mutate(stat = .data$t) %>%
        dplyr::rename(padj = "adj.P.Val") %>%
        dplyr::rename(baseMean = "AveExpr")
    }) %>% 
    purrr::list_rbind()
  
  # Output_Temp data.frame to Output_DE list of data.frames
  Output_DE <- Output_Temp %>%
    plyr::dlply("contrast", identity) %>%
    purrr::map(function(x) {
      x %>%
        dplyr::relocate("log2FoldChange", .before = "baseMean") %>%
        dplyr::arrange(.data$padj)
    })
  
  
  
  
  # Normalized Expression Data ----------------------------------------------
  Normalized_Expression <- list(data.matrix(Expression))
  names(Normalized_Expression) <- Expression_name
  
  if (!is.null(Exps_list) &
      is.list(Exps_list)) {
    Exps_list_dm <- Exps_list %>%
      purrr::map(function(x) {
        data.matrix(x)
      })
    
    Normalized_Expression <- Normalized_Expression %>%
      append(Exps_list_dm)
  }
  
  # Check Mapper
  if (is.null(Mapper)) {
    Features_names_List <- Normalized_Expression %>%
      purrr::map(function(x) {
        Features_names <- rownames(x) %>%
          sort()
        
        return(Features_names)
       
      })
    
    tempMap <- Features_names_List %>%
      unlist(use.names = FALSE) %>%
      unique()
    
    mapperFrame <- data.frame(Feature = tempMap,
                              stringsAsFactors = FALSE)
  } else if (!is.null(Mapper)) {
    mapperFrame <- base::as.data.frame(Mapper)
  }
  
  # check auxiliary_assays 
  if(is.null(auxiliary_assays)) {
    
    samplesNames <- rownames(coldata)
    
    auxiliary_assays <- auxiliary_assays_frame(SampleIDs = samplesNames) 
  } 
  # Hotgenes ----------------------------------------------------------------
  # Special Original_Object handeling
  Expression$limmafit <- limmafit
  Original_Object <- Expression
  
  
  Hotgenes_Object <- HotgenesUniversal(
    Output_DE = Output_DE,
    Normalized_Expression = Normalized_Expression,
    auxiliary_assays = auxiliary_assays,
    coldata = coldata,
    designMatrix = limmafit[["design"]],
    contrastMatrix  = limmafit[["contrasts"]],
    Original_Object = Original_Object,
    Mapper = mapperFrame
  )
  
  
  
  return(Hotgenes_Object)
}
