% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GSEA.R
\name{GSEA_Support}
\alias{GSEA_Support}
\alias{fgsea_}
\alias{fgsea_Results}
\alias{wrap_fixed_names}
\alias{GSEA_Plots}
\alias{leadingGenes}
\alias{plotEnrichment_}
\alias{OntologyMethods}
\alias{OntologyFunctions}
\alias{msigdbr_wrapper_choices}
\alias{msigdbr_wrapper}
\alias{make_custom_geneset_library}
\title{Support functions for GSEA}
\usage{
fgsea_(
  Ranks = NULL,
  pathways = NULL,
  minSize = 1,
  maxSize = Inf,
  nproc = 1,
  ...
)

fgsea_Results(
  fgseaRes = NULL,
  Topn = Inf,
  padj_cut = 0.1,
  contrasts = NULL,
  mode = "Details"
)

wrap_fixed_names(
  string,
  width = 80,
  indent = 0,
  exdent = 0,
  pattern = "_",
  replacement = " "
)

GSEA_Plots(
  fgseaRes = NULL,
  Topn = 10,
  padj_cut = 0.1,
  contrasts = NULL,
  width = 50
)

leadingGenes(fgseaRes = NULL, contrast = NULL, genesetName = NULL)

plotEnrichment_(fgseaRes = NULL, contrast = NULL, genesetName = NULL)

OntologyMethods(
  Ontology_Function = list(msigdbr = msigdbr_wrapper),
  InputChoices = list(msigdbr = msigdbr_wrapper_choices()$set),
  gene_col_choices = list(msigdbr = c("gene_symbol", "entrez_gene", "ensembl_gene")),
  species_choices = list(msigdbr = c("human", "mouse", "rat", "dog")),
  versions = list(msigdbr = packageVersion("msigdbr"))
)

OntologyFunctions(
  Methods = NULL,
  db = NULL,
  species = NULL,
  set = NULL,
  gene_col = NULL,
  ...
)

msigdbr_wrapper_choices()

msigdbr_wrapper(
  species = "human",
  set = NULL,
  gene_col = NULL,
  clean_names = TRUE
)

make_custom_geneset_library(
  library_name = "custom",
  source_genesets = NULL,
  source_requirements = NULL,
  versions = NULL
)
}
\arguments{
\item{Ranks}{A named list containing gene stats in
descending order.}

\item{pathways}{List of gene sets to check.}

\item{minSize}{Minimal size of a gene set to test. All pathways below the threshold are excluded.}

\item{maxSize}{Maximal size of a gene set to test. All pathways above the threshold are excluded.}

\item{nproc}{If not equal to zero sets BPPARAM to use nproc workers (default = 0).}

\item{...}{additional args passed to supplied methods}

\item{fgseaRes}{A named list containing the output from
fgsea_.}

\item{Topn}{number indicating the top number of pathways to show.
Results grouped by sign(NES) and then Topn max
absolute NES selected.}

\item{padj_cut}{numeric value for padj limit (0.1 is Default).}

\item{contrasts}{vector for DE data.frames in Output_DE slot to return.
See ?contrasts_. If NULL (default), all contrasts used.}

\item{mode}{vector indicating the details to return.
Options include,
Details (Complete pathway details per contrast),
leadingEdge (vector for of the column with the same name
Length (Number pathways per contrast),}

\item{string}{Input vector. Either a character vector, or something
coercible to one.}

\item{width}{Positive integer giving target line width (in number of
characters). A width less than or equal to 1 will put each word on its
own line.}

\item{indent, exdent}{A non-negative integer giving the indent for the
first line (\code{indent}) and all subsequent lines (\code{exdent}).}

\item{pattern}{Pattern to look for.

The default interpretation is a regular expression, as described
in \link[stringi:about_search_regex]{stringi::about_search_regex}. Control options with
\code{\link[stringr:regex]{regex()}}.

For \code{str_replace_all()} this can also be a named vector
(\code{c(pattern1 = replacement1)}), in order to perform multiple replacements
in each element of \code{string}.

Match a fixed string (i.e. by comparing only bytes), using
\code{\link[stringr:fixed]{fixed()}}. This is fast, but approximate. Generally,
for matching human text, you'll want \code{\link[stringr:coll]{coll()}} which
respects character matching rules for the specified locale.}

\item{replacement}{The replacement value, usually a single string,
but it can be the a vector the same length as \code{string} or \code{pattern}.
References of the form \verb{\\1}, \verb{\\2}, etc will be replaced with
the contents of the respective matched group (created by \verb{()}).

Alternatively, supply a function, which will be called once for each
match (from right to left) and its return value will be used to replace
the match.}

\item{contrast}{String indicating the contrast to select.}

\item{genesetName}{String indicating the pathway to return.}

\item{Ontology_Function}{a named list containing
functions for returning a named list of geneset
for GSVA/GSEA analysis.}

\item{InputChoices}{a named list containing a
vector with string choices corresponding to ontology choices
for supplied ontology functions.}

\item{gene_col_choices}{a named list containing a
vector with string choices corresponding to gene id choices
for supplied ontology functions.}

\item{species_choices}{a named list containing a
vector with string choices corresponding to species choices
for supplied ontology functions.}

\item{versions}{stringr for version to append
to database name. This will be concantenated to name
in shiny app.}

\item{Methods}{output of OntologyMethods function}

\item{db}{string indicating the ontology database to use.}

\item{species}{maps to the species argument of \link[msigdbr]{msigdbr}.}

\item{set}{maps to the gs_subcollection argument of \link[msigdbr]{msigdbr}, 
when not an empty string. If gs_subcollection is an empty string, uses gs_collection. 
Multiple okay.}

\item{gene_col}{string specifying id to use.
Choices include "gene_symbol" (default),}

\item{clean_names}{Logical, if TRUE (default) geneset names are passed to
\link[janitor]{make_clean_names}}

\item{library_name}{string to call this.}

\item{source_genesets}{a long format dataframe with the following 
columns: 'species', 'set', 'geneset_names', 'aliase_category', 'aliases', 
corresponding to species, geneset category, 
gene set names, gene alias category, and alias values (respectively).}

\item{source_requirements}{a named list of
input requirements. Must include:
'species_choices', 'InputChoices', and 'gene_col_choices', 
popluated with vector choices for species, geneset categories, 
and gene alias categories (respectively).}
}
\description{
`OntologyMethods()` and `OntologyFunctions()` work together
to supply geneset library functions for the `Shiny_Hotgenes()` app.

The `msigdbr_wrapper()` function is a wrapper that
is used supply the default Ontology_Function argument for
`OntologyMethods()`, although it can be used as a standalone
function for supplying genesets.
}
\details{
`fgsea_()` detects for ranks that are all positive or
all negative and then switches to "pos" or "neg", depending on the outcome.
Otherwise scoreType is "std"

`msigdbr_wrapper()` returns a named list containing genesets provided
by msigdbr. List object names are supplied by the "gs_name" column
and are populated by the column specify by the gene_col argument.
}
\examples{
if(interactive()){
  # Getting example data ----------------------------------------------------
  
  # load package
  library(Hotgenes)
  
  dds_Hotgenes_dir <- system.file("extdata",
                                  paste0("dds_Hotgenes", ".RDS"),
                                  package = "Hotgenes",
                                  mustWork = TRUE
  )
  # from DESeq2
  htgs <- readRDS(dds_Hotgenes_dir)
  
  # load signatures using msigdbr wrapper
  # This returns a named list of pathways
  
  H_paths <- msigdbr_wrapper(
    species = "human",
    set = c("CP:REACTOME", "CP:KEGG"),
    gene_col = "gene_symbol"
  )
  
  H_paths \%>\% names() \%>\% head()
  # custom geneset functions can be supplied like this
  # This can be used in the Shiny_Hotgenes() function
  Custom_geneset_function_list <- OntologyMethods(
    Ontology_Function = list("msigdbr" = msigdbr_wrapper),
    InputChoices = list("msigdbr" = c("CP:REACTOME", "CP:KEGG")),
    gene_col_choices = list("msigdbr" = c(
      "gene_symbol", "entrez_gene", "ensembl_gene"
    )),
    species_choices = list("msigdbr" = c("human", "mouse", "rat", "dog")),
    versions = list("msigdbr" = packageVersion("msigdbr"))
  )
  
  
  msigdbr_pthyways <- OntologyFunctions(
    Methods = Custom_geneset_function_list,
    db = "msigdbr",
    species = "human",
    set = c("CP:REACTOME", "CP:KEGG"),
    gene_col = "gene_symbol"
  )
  
  testthat::expect_equal(H_paths, msigdbr_pthyways)
  
  # These genes sets are mapped to gene symbols
  # Verify Feature col contains gene symbols, too
  # In this example the "Feature" column contains gene symbols
  
  htgs \%>\% Mapper_()
  
  # Get ranks
  InputRanks <- htgs \%>\%
    DE(
      Report = "Ranks",
      contrasts = "Hrs_2_vs_0",
      Rank_name = "Feature", # see above
      padj_cut = 1
    )
  
  
  # fgsea wrapper --------
  Out_GSEA <- fgsea_(
    Ranks = InputRanks,
    pathways = H_paths,
    nproc = 8,
    minSize = 5,
    maxSize = Inf
  )
  
  # Get details for all
  Out_GSEA \%>\%
    fgsea_Results(
      padj_cut = 0.2,
      mode = "D"
    )
  
  # Or for one
  Out_GSEA \%>\%
    fgsea_Results(
      contrasts = "Hrs_2_vs_0",
      padj_cut = 0.2,
      mode = "leadingEdge"
    )
  
  # Generate a summary plot
  Out_GSEA \%>\%
    GSEA_Plots(
      contrasts = "Hrs_2_vs_0",
      padj_cut = 0.2,
      width = 30,
      Topn = 2
    )
  
  # plotEnrichment_
  plotEnrichment_(
    Out_GSEA, "Hrs_2_vs_0",
    "kegg_nod_like_receptor_signaling_pathway"
  )
  
  
  # leadingGenes
  leadingGenes(
    Out_GSEA, "Hrs_2_vs_0",
    "kegg_nod_like_receptor_signaling_pathway"
  )
  
}
}
