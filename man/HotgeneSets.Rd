% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GSVA.R
\name{HotgeneSets}
\alias{HotgeneSets}
\title{Support functions for GSVA}
\usage{
HotgeneSets(
  Hotgenes = NULL,
  ExpressionSlots = NULL,
  geneSets = NULL,
  method = c("ssgsea"),
  kcdf = c("Gaussian"),
  minSize = 2,
  maxSize = Inf,
  MapperCol = "Feature",
  voomaGroup = NULL,
  contrast_matrix = NULL,
  use_weights = TRUE,
  use_vooma = FALSE,
  ...
)
}
\arguments{
\item{Hotgenes}{Hotgenes object.}

\item{ExpressionSlots}{name of normalized data to use.
If NULL (default), the first name returned by ExpressionSlots_
will be used.
See HotgenesObj.}

\item{geneSets}{The gene sets.  Must be one of the classes supported by
\code{\linkS4class{GsvaGeneSets}}.}

\item{method}{string for method to use for GSVA package. Options
include: c("ssgsea","gsva", "zscore", "plage").}

\item{kcdf}{Character vector of length 1 denoting the kernel to use during
the non-parametric estimation of the cumulative distribution function of
expression levels across samples.  By default, \code{kcdf="Gaussian"} which is
suitable when input expression values are continuous, such as microarray
fluorescent units in logarithmic scale, RNA-seq log-CPMs, log-RPKMs or
log-TPMs.  When input expression values are integer counts, such as those
derived from RNA-seq experiments, then this argument should be set to
\code{kcdf="Poisson"}.}

\item{minSize}{Minimum size of the resulting gene sets after gene identifier
mapping. By default, the minimum size is 1.}

\item{maxSize}{Maximum size of the resulting gene sets after gene identifier
mapping. By default, the maximum size is \code{Inf}.}

\item{MapperCol}{String matching a column name returned by
Mapper_ function, default is "Feature".}

\item{voomaGroup}{string indicating the column name to be
passed to voomaByGroup(). Default is NULL. Ignored when
use_vooma = FALSE.}

\item{contrast_matrix}{an optional matrix with contrasts to be passed to
\code{\link[limma]{contrasts.fit}}.}

\item{use_weights}{logical, if TRUE (default) gene set sizes applied to 
ebayes trend. If FALSE, trend set to FALSE}

\item{use_vooma}{logical, if TRUE gsva matrix
passed to vooma before lmFit. If FALSE (default),
gsva matrix converted to EList object
and directly passed lmFit.}

\item{...}{Additional parameters for \code{\link[GSVA]{gsva}}.}
}
\description{
Support functions for GSVA
}
\examples{
if(interactive()) {
  require(Hotgenes)
  
  # incase you wanted to include aliases for your genes
  # requires a "Feature" column that contains gene names in expression matrix
  dbCon <- org.Hs.eg.db::org.Hs.eg_dbconn()
  sqlQuery <-
    "SELECT * FROM ENSEMBL, gene_info WHERE ENSEMBL._id == gene_info._id;"
  
  ensembl_Symbol <- DBI::dbGetQuery(dbCon, sqlQuery) \%>\%
    dplyr::select(c("Feature" = "symbol", "ensembl_id"))
  
  
  ensembl_Symbol \%>\% head()
  
  # Hotgeneslimma -----------------------------------------------------------
  require(DESeq2)
  #require(limma)
  #require(edgeR)
  
  dds_con_dir <- system.file("extdata",
                             "dds_con.Rdata",
                             package = "Hotgenes",
                             mustWork = TRUE)
  load(dds_con_dir)
  
  # Example Expression data and coldata
  cts <- counts(dds_con) \%>\% as.data.frame()
  Design <- colData(dds_con) \%>\%
    base::as.data.frame() \%>\%
    dplyr::select_if(is.factor) \%>\%
    dplyr::mutate(Time = as.numeric(levels(.data$Hrs))[.data$Hrs])
  
  # Create DGEList object
  # and calculate normalization factors
  d0 <- edgeR::DGEList(cts)
  d0 <- edgeR::calcNormFactors(d0)
  
  # Filter low-expressed genes
  # disabled in this example
  if (FALSE) {
    cutoff <- 1
    drop <- which(apply(cpm(d0), 1, max) < cutoff)
    d <- d0[-drop,]
    dim(d) # number of genes lef
  }
  
  d <- d0
  
  # make a model.matrix
  model_Matrix <- model.matrix( ~ sh * Hrs,
                                data = Design)
  # voom
  vm_exp <- limma::voom(d, model_Matrix, plot = TRUE)
  
  # make fit
  fit <- limma::lmFit(vm_exp, model_Matrix)
  fit <- limma::eBayes(fit)
  
  # Get alternative exps
  alt_Exp <- list(counts = data.matrix(d0))
  
  # Convert to Hotgenes Object
  fit_Hotgenes <- Hotgeneslimma(
    limmafit = fit,
    coldata = Design,
    Expression = vm_exp,
    Expression_name = "logCPM",
    Exps_list = alt_Exp,
    Mapper = ensembl_Symbol
  )
  
  fit_Hotgenes
  
  # with contrasts ----------------------------------------------------------
  
  # make a model.matrix
  model_Matrix_2 <- model.matrix( ~ 0 + sh,
                                data = Design)
  # voom
  contrast_m <- limma_paired_contrasts(c("shEWS", "shCtrl"),
                                       modelMatrix= model_Matrix_2)
  head(contrast_m)
  
  # voom
  vm_exp <- limma::voom(d, model_Matrix_2, plot = TRUE)
  
  # make fit
  fit <- limma::lmFit(vm_exp, model_Matrix_2)
  fit2 <- limma::contrasts.fit(fit = fit, contrasts = contrast_m)
  
  fit2 <- limma::eBayes(fit2)
  
  # Get alternative exps
  alt_Exp <- list(counts = data.matrix(d0))
  
  # Convert to Hotgenes Object
  fit_Hotgenes_contrast <- Hotgeneslimma(
    limmafit = fit2,
    coldata = Design,
    Expression = vm_exp,
    Expression_name = "logCPM",
    Exps_list = alt_Exp,
    Mapper = ensembl_Symbol
  )
  
  fit_Hotgenes_contrast
  
  
  
  
}
}
